#!/usr/bin/env python3
from flask import Flask, jsonify, request, render_template, session, redirect, url_for
from functools import wraps
import json
import subprocess
import shutil
import os
import time
import hashlib
import struct
import sys
from threading import Lock

# Add current directory to path to import drivers
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

app = Flask(__name__)
app.config['SECRET_KEY'] = 'decoder-web-secret-key-change-in-production'
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'

# Default credentials
ADMIN_USERNAME = 'admin'
ADMIN_PASSWORD_HASH = hashlib.sha256('admin123'.encode()).hexdigest()

PLAYER_PROC = None
TEST_PROC = None
CURRENT_VOLUME = 100

BG_PROCS = {1: None, 2: None}

DEFAULT_CONFIG = {
    'stream_url': '',
    'stream_url1': '',
    'stream_url2': '',
    'current_stream_idx': 1,
    'device': 'hw:0,0',
    'volume': 100,
    'test_frequency': 440,
    'test_duration': 5,
    'test_device': 'hw:0,0'
}

CONFIG_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'config.json')
CONFIG_LOCK = Lock()


def load_config():
    config = DEFAULT_CONFIG.copy()
    try:
        with open(CONFIG_PATH, 'r', encoding='utf-8') as handle:
            data = json.load(handle)
        if isinstance(data, dict):
            for key in config:
                if key in data:
                    config[key] = data[key]
    except Exception:
        pass
    return config


CONFIG = load_config()


def persist_config():
    try:
        with open(CONFIG_PATH, 'w', encoding='utf-8') as handle:
            json.dump(CONFIG, handle, indent=2)
    except Exception as err:
        app.logger.warning('Failed to write config: %s', err)


def update_config(**updates):
    changed = False
    with CONFIG_LOCK:
        for key, value in updates.items():
            if key not in CONFIG or value is None:
                continue
            if CONFIG.get(key) != value:
                CONFIG[key] = value
                changed = True
        if changed:
            persist_config()
    return CONFIG



def normalize_url(u: str) -> str:
    u=(u or '').strip()
    if not u:
        return u
    import re as _re
    if not _re.match(r'^[a-zA-Z][a-zA-Z0-9+.-]*://', u):
        return 'http://' + u
    return u

def parse_request_payload():
    data = request.get_json(silent=True)
    if isinstance(data, dict):
        return data
    if request.form:
        return request.form.to_dict()
    raw = request.get_data(as_text=True).strip()
    if raw:
        try:
            return json.loads(raw)
        except json.JSONDecodeError:
            app.logger.warning('Invalid JSON payload: %s', raw[:200])
    return {}

def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'logged_in' not in session:
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function

def stop_player():
    global PLAYER_PROC
    try:
        if PLAYER_PROC and PLAYER_PROC.poll() is None:
            PLAYER_PROC.terminate()
            try:
                PLAYER_PROC.wait(timeout=1)
            except Exception:
                pass
        subprocess.run(['pkill','-x','cvlc'], check=False)
        subprocess.run(['pkill','-x','ffmpeg'], check=False)
        subprocess.run(['pkill','-x','aplay'], check=False)
        subprocess.run(['pkill','-x','mpg123'], check=False)
    except Exception:
        pass
    PLAYER_PROC = None

def stop_test():
    global TEST_PROC
    try:
        if TEST_PROC and TEST_PROC.poll() is None:
            TEST_PROC.terminate()
            try:
                TEST_PROC.wait(timeout=1)
            except Exception:
                pass
        subprocess.run(['pkill','-f','test_pcm5102a'], check=False)
        subprocess.run(['pkill','-f','simple_test'], check=False)
        subprocess.run(['pkill','-f','speaker-test'], check=False)
    except Exception:
        pass
    TEST_PROC = None

def start_player(url: str, out_dev: str = 'hw:0,0', volume: int = 100) -> bool:
    global PLAYER_PROC, CURRENT_VOLUME
    stop_player()
    CURRENT_VOLUME = volume
    
    # Try VLC first (supports most codecs: MP3, OGG, WAV, AAC, FLAC, etc.)
    cvlc = shutil.which('cvlc') or '/usr/bin/cvlc'
    if os.path.exists(cvlc):
        try:
            vol_percent = int(volume * 256 / 100)  # VLC volume 0-256
            vol_percent = max(0, min(256, vol_percent))
            PLAYER_PROC = subprocess.Popen([
                cvlc, '--intf','dummy','--no-video','--quiet',
                '--aout','alsa', f'--alsa-audio-device={out_dev}',
                '--network-caching','8000','--live-caching','12000',
                '--volume', str(vol_percent),
                url
            ], stdin=subprocess.DEVNULL, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            time.sleep(1.5)
            if PLAYER_PROC.poll() is None:
                return True
        except Exception:
            pass
    
    # Fallback: ffmpeg -> aplay (supports many formats)
    ffmpeg = shutil.which('ffmpeg') or '/usr/bin/ffmpeg'
    aplay = shutil.which('aplay') or '/usr/bin/aplay'
    if os.path.exists(ffmpeg) and os.path.exists(aplay):
        try:
            vol_gain = 20 * (volume / 100) - 20  # Volume in dB
            PLAYER_PROC = subprocess.Popen([
                ffmpeg,'-nostdin','-reconnect','1','-reconnect_streamed','1',
                '-reconnect_delay_max','10', '-i', url,
                '-f','s16le','-ac','2','-ar','44100',
                '-af',f'volume={vol_gain}dB','-'
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            ap = subprocess.Popen([aplay,'-D',out_dev,'-f','cd','-c','2','-r','44100'], 
                                stdin=PLAYER_PROC.stdout)
            PLAYER_PROC.stdout.close()
            time.sleep(1.5)
            if PLAYER_PROC.poll() is None and ap.poll() is None:
                return True
        except Exception:
            pass
    
    # Fallback: mpg123 for MP3 streams
    mpg123 = shutil.which('mpg123') or '/usr/bin/mpg123'
    if os.path.exists(mpg123):
        try:
            vol_db = 20 * (volume / 100) - 20
            PLAYER_PROC = subprocess.Popen([
                mpg123,'-q','-g', str(vol_db), url
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            ap = subprocess.Popen([aplay,'-D',out_dev,'-f','cd','-c','2','-r','44100'], 
                                stdin=PLAYER_PROC.stdout)
            PLAYER_PROC.stdout.close()
            time.sleep(1.5)
            if PLAYER_PROC.poll() is None and ap.poll() is None:
                return True
        except Exception:
            pass
    
    stop_player()
    return False

def start_test_tone(frequency: int = 440, duration: int = 5, device: str = 'hw:0,0', volume: int = 100) -> bool:
    global TEST_PROC
    stop_test()
    
    # Try using speaker-test (ALSA utility)
    speaker_test = shutil.which('speaker-test') or '/usr/bin/speaker-test'
    if os.path.exists(speaker_test):
        try:
            # speaker-test generates sine wave tones
            vol_pct = volume
            TEST_PROC = subprocess.Popen([
                speaker_test, '-t', 'sine', '-f', str(frequency),
                '-c', '2', '-s', '1', '-D', device, '-l', '1'
            ], stdin=subprocess.DEVNULL, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            time.sleep(0.5)
            if TEST_PROC.poll() is None:
                # Schedule stop after duration
                def stop_after_delay():
                    time.sleep(duration)
                    stop_test()
                import threading
                threading.Thread(target=stop_after_delay, daemon=True).start()
                return True
        except Exception:
            pass
    
    # Fallback: Use Python to generate tone and pipe to aplay
    try:
        import math
        import wave
        import tempfile
        
        sample_rate = 44100
        num_samples = int(sample_rate * duration)
        amplitude = int(32767 * volume / 100)
        
        # Generate sine wave
        samples = []
        for i in range(num_samples):
            value = int(amplitude * math.sin(2 * math.pi * frequency * i / sample_rate))
            samples.append(struct.pack('<hh', value, value))  # Stereo 16-bit
        
        # Write to temporary WAV file
        with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as f:
            temp_wav = f.name
            with wave.open(temp_wav, 'wb') as w:
                w.setnchannels(2)
                w.setsampwidth(2)
                w.setframerate(sample_rate)
                w.writeframes(b''.join(samples))
        
        # Play with aplay
        aplay = shutil.which('aplay') or '/usr/bin/aplay'
        if os.path.exists(aplay):
            TEST_PROC = subprocess.Popen([aplay, '-D', device, temp_wav],
                                        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            time.sleep(0.5)
            if TEST_PROC.poll() is None:
                def cleanup():
                    TEST_PROC.wait()
                    try:
                        os.unlink(temp_wav)
                    except:
                        pass
                import threading
                threading.Thread(target=cleanup, daemon=True).start()
                return True
    except Exception as e:
        pass
    
    stop_test()
    return False

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form.get('username', '').strip()
        password = request.form.get('password', '').strip()
        
        password_hash = hashlib.sha256(password.encode()).hexdigest()
        
        if username == ADMIN_USERNAME and password_hash == ADMIN_PASSWORD_HASH:
            session['logged_in'] = True
            session['username'] = username
            return redirect(url_for('index'))
        else:
            return render_template('login.html', error='Invalid username or password')
    
    return render_template('login.html')

@app.route('/logout')
def logout():
    session.clear()
    return redirect(url_for('login'))

@app.route('/')
@login_required
def index():
    return render_template('index.html', session=session, config=CONFIG)

@app.route('/api/start', methods=['POST'])
@login_required
def api_start():
    try:
        data = parse_request_payload()
        if not data:
            return jsonify(success=False, message='Missing request body'), 400
        url = data.get('url','').strip()
        out = data.get('device','hw:0,0').strip() or 'hw:0,0'
        volume = int(data.get('volume', 100))
        volume = max(0, min(100, volume))
        
        if not url:
            return jsonify(success=False, message='Missing url'), 400
        
        ok = start_player(url, out, volume)
        if ok:
            update_config(stream_url=url, device=out, volume=volume)
        return jsonify(success=ok, message='Started' if ok else 'Failed to start')
    except Exception as e:
        return jsonify(success=False, message=str(e)), 500

@app.route('/api/stop', methods=['POST'])
@login_required
def api_stop():
    stop_player()
    return jsonify(success=True)

@app.route('/api/test/start', methods=['POST'])
@login_required
def api_test_start():
    try:
        data = parse_request_payload()
        if not data:
            return jsonify(success=False, message='Missing request body'), 400
        frequency = int(data.get('frequency', 440))
        duration = int(data.get('duration', 5))
        device = data.get('device', 'hw:0,0').strip() or 'hw:0,0'
        volume = int(data.get('volume', 100))
        volume = max(0, min(100, volume))
        frequency = max(20, min(20000, frequency))
        duration = max(1, min(60, duration))
        
        ok = start_test_tone(frequency, duration, device, volume)
        if ok:
            update_config(
                test_frequency=frequency,
                test_duration=duration,
                test_device=device,
                volume=volume
            )
        return jsonify(success=ok, message='Test tone started' if ok else 'Failed to start test tone')
    except Exception as e:
        return jsonify(success=False, message=str(e)), 500

@app.route('/api/test/stop', methods=['POST'])
@login_required
def api_test_stop():
    stop_test()
    return jsonify(success=True)

@app.route('/api/volume', methods=['POST'])
@login_required
def api_volume():
    try:
        data = parse_request_payload()
        if not data:
            return jsonify(success=False, message='Missing request body'), 400
        volume = int(data.get('volume', 100))
        volume = max(0, min(100, volume))
        
        global CURRENT_VOLUME, PLAYER_PROC
        CURRENT_VOLUME = volume
        update_config(volume=volume)
        
        # Try to change volume on running player (requires restart for most players)
        if PLAYER_PROC and PLAYER_PROC.poll() is None:
            # VLC volume control via dbus or restart needed
            # For now, just store volume for next start
            pass
        
        return jsonify(success=True, volume=volume)
    except Exception as e:
        return jsonify(success=False, message=str(e)), 500

@app.route('/api/status', methods=['GET'])
@login_required
def api_status():
    is_running = PLAYER_PROC is not None and PLAYER_PROC.poll() is None
    is_testing = TEST_PROC is not None and TEST_PROC.poll() is None
    return jsonify({
        'playing': is_running,
        'testing': is_testing,
        'volume': CURRENT_VOLUME
    })

@app.route('/api/levels')
@login_required
def api_levels():
    try:
        url = request.args.get('url','').strip()
        url = normalize_url(url)
        if not url:
            return jsonify(success=False, message='missing url'), 400
        import subprocess, array, os, math, shutil
        ff = shutil.which('ffmpeg') or '/usr/bin/ffmpeg'
        if not os.path.exists(ff):
            return jsonify(success=False, message='ffmpeg missing'), 500
        proc = subprocess.Popen([ff,'-hide_banner','-loglevel','error','-t','0.15','-vn','-sn','-dn','-i',url,
                                 '-f','s16le','-ac','2','-ar','16000','-'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        data = proc.stdout.read(16000*2*2//6) if proc.stdout else b''
        try: proc.terminate()
        except Exception: pass
        if not data:
            return jsonify(success=True, L=0.0, R=0.0)
        samples = array.array('h'); samples.frombytes(data)
        n=len(samples)//2
        if n<=0:
            return jsonify(success=True, L=0.0, R=0.0)
        peakL=peakR=0
        for i in range(0,n*2,2):
            a=abs(samples[i]); b=abs(samples[i+1])
            if a>peakL: peakL=a
            if b>peakR: peakR=b
        def to_dbfs(pk):
            import math
            return round(20*math.log10(max(1e-6, pk/32767.0)),1)
        return jsonify(success=True, L_db=to_dbfs(peakL), R_db=to_dbfs(peakR))
    except Exception as e:
        return jsonify(success=False, message=str(e)), 500

@app.route('/api/output_levels')
@login_required
def api_output_levels():
    try:
        import json, os, time
        path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'levels.json')
        with open(path, 'r', encoding='utf-8') as f:
            j = json.load(f)
        return jsonify(success=True, levels=j)
    except Exception as e:
        return jsonify(success=False, message=str(e)), 500


@app.route('/api/switch', methods=['POST'])
@login_required
def api_switch():
    try:
        data = parse_request_payload()
        url = normalize_url(data.get('url2','').strip())
        out = 'hw:0,0'
        if not url:
            return jsonify(success=False, message='No url2 provided'), 400
        stop_player()
        ok = start_player(url, out)
        if ok:
            try:
                update_config(stream_url=url)
            except Exception:
                pass
        return jsonify(success=ok)
    except Exception as e:
        return jsonify(success=False, message=str(e)), 500

@app.route('/api/config', methods=['GET', 'POST'])
@login_required
def api_config():
    if request.method == 'GET':
        return jsonify(success=True, config=CONFIG)
    data = parse_request_payload()
    if not data:
        return jsonify(success=False, message='Missing request body'), 400
    updates = {}
    if 'stream_url1' in data:
        updates['stream_url1'] = normalize_url(data.get('stream_url1',''))
    if 'stream_url2' in data:
        updates['stream_url2'] = normalize_url(data.get('stream_url2',''))
    if 'stream_url' in data:
        updates['stream_url'] = data.get('stream_url', '').strip()
    if 'device' in data:
        updates['device'] = data.get('device', '').strip() or 'hw:0,0'
    if 'volume' in data:
        updates['volume'] = max(0, min(100, int(data.get('volume', 100))))
    if 'test_frequency' in data:
        updates['test_frequency'] = max(20, min(20000, int(data.get('test_frequency', 440))))
    if 'test_duration' in data:
        updates['test_duration'] = max(1, min(60, int(data.get('test_duration', 5))))
    if 'test_device' in data:
        updates['test_device'] = data.get('test_device', '').strip() or 'hw:0,0'
    new_config = update_config(**updates)
    return jsonify(success=True, config=new_config)


def get_active_url() -> str:
    idx = int(CONFIG.get('current_stream_idx', 1) or 1)
    if idx == 1:
        u = CONFIG.get('stream_url1', '')
    else:
        u = CONFIG.get('stream_url2', '')
    return normalize_url(u)

@app.route('/api/toggle', methods=['POST'])
@login_required
def api_toggle():
    try:
        cur = int(CONFIG.get('current_stream_idx', 1) or 1)
        new_idx = 2 if cur == 1 else 1
        update_config(current_stream_idx=new_idx)
        url = CONFIG.get('stream_url1','') if new_idx == 1 else CONFIG.get('stream_url2','')
        url = normalize_url(url)
        if not url:
            return jsonify(success=False, message='No link configured'), 400
        stop_player()
        ok = start_player(url, CONFIG.get('device','hw:0,0'), int(CONFIG.get('volume', 100)))
        if ok:
            update_config(stream_url=url)
        return jsonify(success=ok, active_idx=new_idx)
    except Exception as e:
        return jsonify(success=False, message=str(e)), 500


from urllib.request import urlopen, Request
from urllib.error import URLError, HTTPError

def _health_of(url: str, timeout: float = 2.0) -> bool:
    try:
        if not url:
            return False
        req = Request(url, headers={'User-Agent':'Mozilla/5.0'})
        with urlopen(req, timeout=timeout) as r:
            r.read(512)
        return True
    except Exception:
        return False


def _bg_running_for_url(url: str) -> bool:
    if not url:
        return False
    try:
        out = _sp.check_output(['pgrep','-af','ffmpeg'], text=True)
        for line in out.splitlines():
            if url in line and ' -f null -' in line:
                return True
    except Exception:
        pass
    return False

@app.route('/api/link_health', methods=['GET'])

@login_required
def api_link_health():
    u1 = CONFIG.get('stream_url1','')
    u2 = CONFIG.get('stream_url2','')
    return jsonify(success=True, l1=_health_of(normalize_url(u1) if u1 else ''), l2=_health_of(normalize_url(u2) if u2 else ''))


def _start_bg_for(idx: int) -> bool:
    url = CONFIG.get('stream_url1','') if idx == 1 else CONFIG.get('stream_url2','')
    url = normalize_url(url)
    if not url:
        return False
    # Prefer ffmpeg piping to null
    import shutil, subprocess
    ff = shutil.which('ffmpeg') or '/usr/bin/ffmpeg'
    if os.path.exists(ff):
        try:
            proc = subprocess.Popen([ff,'-hide_banner','-loglevel','error','-reconnect','1','-reconnect_streamed','1','-reconnect_delay_max','10','-i',url,'-f','null','-'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            BG_PROCS[idx] = proc
            return True
        except Exception:
            pass
    # Fallback: curl
    curl = shutil.which('curl') or '/usr/bin/curl'
    if os.path.exists(curl):
        try:
            proc = subprocess.Popen([curl,'-L','--fail','--silent','--show-error',url], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            BG_PROCS[idx] = proc
            return True
        except Exception:
            pass
    return False


def _stop_bg_for(idx: int) -> bool:
    proc = BG_PROCS.get(idx)
    if proc and proc.poll() is None:
        try:
            proc.terminate()
        except Exception:
            pass
    BG_PROCS[idx] = None
    return True

@app.route('/api/link/<int:idx>/start_bg', methods=['POST'])
@login_required
def api_link_start_bg(idx: int):
    idx = 1 if idx != 2 else 2
    ok = _start_bg_for(idx)
    return jsonify(success=ok)

@app.route('/api/link/<int:idx>/stop_bg', methods=['POST'])
@login_required
def api_link_stop_bg(idx: int):
    idx = 1 if idx != 2 else 2
    ok = _stop_bg_for(idx)
    return jsonify(success=ok)


FAILOVER_INTERVAL_S = 3
FAILOVER_FAILCOUNT = 3

_last_ok = 0
_fail_count = 0

def _active_url_and_other():
    idx = int(CONFIG.get('current_stream_idx', 1) or 1)
    a = normalize_url(CONFIG.get('stream_url1','')) if idx == 1 else normalize_url(CONFIG.get('stream_url2',''))
    b = normalize_url(CONFIG.get('stream_url2','')) if idx == 1 else normalize_url(CONFIG.get('stream_url1',''))
    return idx, a, b


def monitor_active_loop():
    global _last_ok, _fail_count
    import time
    while True:
        try:
            idx, active, other = _active_url_and_other()
            ok = _health_of(active) if active else False
            if ok:
                _fail_count = 0
            else:
                _fail_count += 1
                # If active failed repeatedly, try other if healthy
                if _fail_count >= FAILOVER_FAILCOUNT:
                    if other and _health_of(other):
                        # Flip active
                        new_idx = 2 if idx == 1 else 1
                        update_config(current_stream_idx=new_idx)
                        stop_player()
                        if start_player(other, CONFIG.get('device','hw:0,0'), int(CONFIG.get('volume',100))):
                            update_config(stream_url=other)
                            _fail_count = 0
            time.sleep(FAILOVER_INTERVAL_S)
        except Exception:
            time.sleep(FAILOVER_INTERVAL_S)

# Start monitor thread once at import
def _start_monitor_once():
    try:
        t = threading.Thread(target=monitor_active_loop, daemon=True)
        t.start()
    except Exception:
        pass

_start_monitor_once()


@app.route('/api/start_dual', methods=['POST'])
@login_required
def api_start_dual():
    try:
        # Start background decoders for both links if configured
        _start_bg_for(1)
        _start_bg_for(2)
        # Route Link 1 to output by default
        update_config(current_stream_idx=1)
        url = normalize_url(CONFIG.get('stream_url1',''))
        if not url:
            # if link1 missing, try link2
            update_config(current_stream_idx=2)
            url = normalize_url(CONFIG.get('stream_url2',''))
        if not url:
            return jsonify(success=False, message='No links configured'), 400
        stop_player()
        ok = start_player(url, CONFIG.get('device','hw:0,0'), int(CONFIG.get('volume',100)))
        if ok:
            update_config(stream_url=url)
        return jsonify(success=ok)
    except Exception as e:
        return jsonify(success=False, message=str(e)), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=False)
